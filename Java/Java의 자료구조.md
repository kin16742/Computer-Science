# Java의 자료구조

## Collection

Collection에서의 data는 기본 데이터형이 아닌 참조 데이터형만 저장이 가능하므로 객체로서 저장한다. 그래서 기본 데이터형은 컴파일러가 자동으로 Wrapper 클래스로 변환해 저장하며 데이터를 꺼낼 때도 자동으로 Unboxing 해준다. 

### List

- 동일한 데이터 중복 허용
- 데이터 저장 순서 유지
- 인덱스로 객체의 주소값을 참조해 저장

1. **LinkedList**
   - 양방향 포인터 구조로 인접한 데이터를 체인처럼 연결해 참조한다.
   - 중간 인덱스에 삽입/삭제를 자주 해야할 때 효율적이다.
   - Stack, Queue 구현에 쓰인다.
2. **Vector**
   - 동기화된 메소드로 구성되어 있다. (여러 개의 스레드가 동시에 실행 불가능)
   - ArrayList와 내부 구조가 동일하다.
3. **ArrayList**
   - 배열과는 달리 크기가 고정되어 있지 않다.
   - 순차적인 삽입/삭제를 자주 해야할 때 효율적이다.
   - 계속 원소를 삽입하면 저장소의 용량을 자동으로 늘리지만, 많은 시간이 소요된다.
   - 중간 인덱스의 원소 삭제 시 뒤의 원소들이 앞으로 한 칸씩 이동하여 인덱스가 갱신된다.

### Set

- 동일한 데이터 중복 허용 X
- 데이터 저장 순서 유지 X
- 인덱스 대신 iterator를 제공 (hasNext(), next() 메소드를 이용해 탐색)

1. **HashSet**
   - 순서에 상관없이 저장된다.
   - Set 중에 성능이 가장 좋다.
   - 해시 함수 이용 
2. **TreeSet**
   - 저장된 데이터의 값에 따라 정렬되어 저장된다.
   - red-black tree 타입으로 값이 저장됨
3. **LinkedHashSet**
   - 저장된 순서에 따라 값이 저장된다.
   - Set 중에 가장 느리다.

## Map

- key와 value로 구성된 entry 객체를 저장하는 구조
- value는 중복을 허용하나, key는 중복을 허용하지 않는다. (덮어씌워진다.)

1. **HashTable**
   - 동기화된 메소드로 여러 스레드에서 동시 사용 가능
   - key, value에 null을 저장할 수 없다.
2. **HashMap**
   - 비동기 메소드로 여러 스레드에서 동시 사용 불가능
   - key, value에 null을 저장할 수 있다.
3. **TreeMap**
   - key 값을 기준으로 정렬된다.